{"ast":null,"code":"import { useRef, useState, useCallback } from 'react';\nfunction createObserverCache() {\n  var cachesByRoot = new Map();\n  function getObserver(_ref) {\n    var root = _ref.root,\n      rootMargin = _ref.rootMargin,\n      threshold = _ref.threshold;\n    var cacheByRoot = cachesByRoot.get(root);\n    if (!cacheByRoot) {\n      cacheByRoot = new Map();\n      cachesByRoot.set(root, cacheByRoot);\n    }\n    var cacheKey = JSON.stringify({\n      rootMargin: rootMargin,\n      threshold: threshold\n    });\n    var cachedObserver = cacheByRoot.get(cacheKey);\n    if (!cachedObserver) {\n      var entryCallbacks = new Map();\n      var observer = new IntersectionObserver(function (entries) {\n        entries.forEach(function (entry) {\n          var callback = entryCallbacks.get(entry.target);\n          callback == null ? void 0 : callback(entry);\n        });\n      }, {\n        root: root,\n        rootMargin: rootMargin,\n        threshold: threshold\n      });\n      cachedObserver = {\n        observer: observer,\n        entryCallbacks: entryCallbacks\n      };\n      cacheByRoot.set(cacheKey, cachedObserver);\n    }\n    return {\n      observe: function observe(node, callback) {\n        var _cachedObserver, _cachedObserver2;\n        (_cachedObserver = cachedObserver) == null ? void 0 : _cachedObserver.entryCallbacks.set(node, callback);\n        (_cachedObserver2 = cachedObserver) == null ? void 0 : _cachedObserver2.observer.observe(node);\n      },\n      unobserve: function unobserve(node) {\n        var _cachedObserver3, _cachedObserver4;\n        (_cachedObserver3 = cachedObserver) == null ? void 0 : _cachedObserver3.entryCallbacks[\"delete\"](node);\n        (_cachedObserver4 = cachedObserver) == null ? void 0 : _cachedObserver4.observer.unobserve(node);\n      }\n    };\n  }\n  return {\n    getObserver: getObserver\n  };\n}\nvar DEFAULT_ROOT_MARGIN = '0px';\nvar DEFAULT_THRESHOLD = [0];\nvar observerCache = /*#__PURE__*/createObserverCache(); // For more info:\n// https://developers.google.com/web/updates/2016/04/intersectionobserver\n// https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n\nfunction useIntersectionObserver(args) {\n  var _args$rootMargin, _args$threshold;\n  var rootMargin = (_args$rootMargin = args == null ? void 0 : args.rootMargin) != null ? _args$rootMargin : DEFAULT_ROOT_MARGIN;\n  var threshold = (_args$threshold = args == null ? void 0 : args.threshold) != null ? _args$threshold : DEFAULT_THRESHOLD;\n  var nodeRef = useRef(null);\n  var rootRef = useRef(null);\n  var observerRef = useRef(null);\n  var _useState = useState(),\n    entry = _useState[0],\n    setEntry = _useState[1];\n  var observe = useCallback(function () {\n    var node = nodeRef.current;\n    if (!node) {\n      setEntry(undefined);\n      return;\n    }\n    var observer = observerCache.getObserver({\n      root: rootRef.current,\n      rootMargin: rootMargin,\n      threshold: threshold\n    });\n    observer.observe(node, function (observedEntry) {\n      setEntry(observedEntry);\n    });\n    observerRef.current = observer;\n  }, [rootMargin, threshold]);\n  var unobserve = useCallback(function () {\n    var currentObserver = observerRef.current;\n    var node = nodeRef.current;\n    if (node) {\n      currentObserver == null ? void 0 : currentObserver.unobserve(node);\n    }\n    observerRef.current = null;\n  }, []); // React will call the ref callback with the DOM element when the component mounts,\n  // and call it with null when it unmounts.\n  // So, we don't need an useEffect etc to unobserve nodes.\n  // When nodeRef.current is null, it will be unobserved and observe function\n  // won't do anything.\n\n  var refCallback = useCallback(function (node) {\n    unobserve();\n    nodeRef.current = node;\n    observe();\n  }, [observe, unobserve]);\n  var rootRefCallback = useCallback(function (rootNode) {\n    unobserve();\n    rootRef.current = rootNode;\n    observe();\n  }, [observe, unobserve]);\n  return [refCallback, {\n    entry: entry,\n    rootRef: rootRefCallback\n  }];\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction useTrackVisibility(args) {\n  var _result$entry;\n  var _useIntersectionObser = useIntersectionObserver(args),\n    ref = _useIntersectionObser[0],\n    result = _useIntersectionObser[1];\n  var isVisible = Boolean((_result$entry = result.entry) == null ? void 0 : _result$entry.isIntersecting);\n  var _useState = useState(isVisible),\n    wasEverVisible = _useState[0],\n    setWasEverVisible = _useState[1];\n  if (isVisible && !wasEverVisible) {\n    setWasEverVisible(true);\n  }\n  return [ref, _extends({}, result, {\n    isVisible: isVisible,\n    wasEverVisible: wasEverVisible\n  })];\n}\nexport { useIntersectionObserver, useTrackVisibility };","map":{"version":3,"names":["createObserverCache","cachesByRoot","Map","getObserver","_ref","root","rootMargin","threshold","cacheByRoot","get","set","cacheKey","JSON","stringify","cachedObserver","entryCallbacks","observer","IntersectionObserver","entries","forEach","entry","callback","target","observe","node","_cachedObserver","_cachedObserver2","unobserve","_cachedObserver3","_cachedObserver4","DEFAULT_ROOT_MARGIN","DEFAULT_THRESHOLD","observerCache","useIntersectionObserver","args","_args$rootMargin","_args$threshold","nodeRef","useRef","rootRef","observerRef","useState","_useState","setEntry","useCallback","current","undefined","observedEntry","currentObserver","refCallback","rootRefCallback","rootNode","useTrackVisibility","ref","_useIntersectionObser","result","isVisible","Boolean","_result$entry","isIntersecting","wasEverVisible","setWasEverVisible","_extends"],"sources":["/Users/AmundFremming/Documents/Konsulent/sketchsauce-ts/node_modules/react-intersection-observer-hook/src/utils.ts","/Users/AmundFremming/Documents/Konsulent/sketchsauce-ts/node_modules/react-intersection-observer-hook/src/useIntersectionObserver.ts","/Users/AmundFremming/Documents/Konsulent/sketchsauce-ts/node_modules/react-intersection-observer-hook/src/useTrackVisibility.ts"],"sourcesContent":["type EntryCallback = (entry: IntersectionObserverEntry) => void;\n\ntype CachedObserver = {\n  observer: IntersectionObserver;\n  entryCallbacks: Map<Element, EntryCallback>;\n};\n\ntype ObserverCache = Map<string, CachedObserver>;\n\ntype ObserverCachesByRoot = Map<\n  IntersectionObserverInit['root'],\n  ObserverCache\n>;\n\nexport type CachedIntersectionObserver = {\n  observe: (\n    node: Element,\n    callback: (entry: IntersectionObserverEntry) => void,\n  ) => void;\n  unobserve: (node: Element) => void;\n};\n\nexport function createObserverCache() {\n  const cachesByRoot: ObserverCachesByRoot = new Map();\n\n  function getObserver({\n    root,\n    rootMargin,\n    threshold,\n  }: IntersectionObserverInit): CachedIntersectionObserver {\n    let cacheByRoot = cachesByRoot.get(root);\n\n    if (!cacheByRoot) {\n      cacheByRoot = new Map();\n      cachesByRoot.set(root, cacheByRoot);\n    }\n\n    const cacheKey = JSON.stringify({ rootMargin, threshold });\n    let cachedObserver = cacheByRoot.get(cacheKey);\n\n    if (!cachedObserver) {\n      const entryCallbacks = new Map<Element, EntryCallback>();\n\n      const observer = new IntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            const callback = entryCallbacks.get(entry.target);\n            callback?.(entry);\n          });\n        },\n        { root, rootMargin, threshold },\n      );\n\n      cachedObserver = { observer, entryCallbacks };\n\n      cacheByRoot.set(cacheKey, cachedObserver);\n    }\n\n    return {\n      observe: (\n        node: Element,\n        callback: (entry: IntersectionObserverEntry) => void,\n      ) => {\n        cachedObserver?.entryCallbacks.set(node, callback);\n        cachedObserver?.observer.observe(node);\n      },\n      unobserve: (node: Element) => {\n        cachedObserver?.entryCallbacks.delete(node);\n        cachedObserver?.observer.unobserve(node);\n      },\n    };\n  }\n\n  return { getObserver };\n}\n","import { useState, useCallback, useRef } from 'react';\nimport { CachedIntersectionObserver, createObserverCache } from './utils';\nimport { Omit } from './types';\n\nconst DEFAULT_ROOT_MARGIN = '0px';\nconst DEFAULT_THRESHOLD = [0];\n\nexport type IntersectionObserverHookArgs = Omit<\n  IntersectionObserverInit,\n  'root'\n>;\n\nexport type IntersectionObserverHookRefCallbackNode = Element | null;\n\nexport type IntersectionObserverHookRefCallback = (\n  node: IntersectionObserverHookRefCallbackNode,\n) => void;\n\nexport type IntersectionObserverHookRootRefCallbackNode = IntersectionObserverInit['root'];\n\nexport type IntersectionObserverHookRootRefCallback = (\n  node: IntersectionObserverHookRootRefCallbackNode,\n) => void;\n\nexport type IntersectionObserverHookResult = [\n  IntersectionObserverHookRefCallback,\n  {\n    entry: IntersectionObserverEntry | undefined;\n    rootRef: IntersectionObserverHookRootRefCallback;\n  },\n];\n\nconst observerCache = createObserverCache();\n\n// For more info:\n// https://developers.google.com/web/updates/2016/04/intersectionobserver\n// https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\nfunction useIntersectionObserver(\n  args?: IntersectionObserverHookArgs,\n): IntersectionObserverHookResult {\n  const rootMargin = args?.rootMargin ?? DEFAULT_ROOT_MARGIN;\n  const threshold = args?.threshold ?? DEFAULT_THRESHOLD;\n\n  const nodeRef = useRef<IntersectionObserverHookRefCallbackNode>(null);\n  const rootRef = useRef<IntersectionObserverHookRootRefCallbackNode>(null);\n  const observerRef = useRef<CachedIntersectionObserver | null>(null);\n\n  const [entry, setEntry] = useState<IntersectionObserverEntry>();\n\n  const observe = useCallback(() => {\n    const node = nodeRef.current;\n\n    if (!node) {\n      setEntry(undefined);\n      return;\n    }\n\n    const observer = observerCache.getObserver({\n      root: rootRef.current,\n      rootMargin,\n      threshold,\n    });\n\n    observer.observe(node, (observedEntry) => {\n      setEntry(observedEntry);\n    });\n\n    observerRef.current = observer;\n  }, [rootMargin, threshold]);\n\n  const unobserve = useCallback(() => {\n    const currentObserver = observerRef.current;\n    const node = nodeRef.current;\n\n    if (node) {\n      currentObserver?.unobserve(node);\n    }\n\n    observerRef.current = null;\n  }, []);\n\n  // React will call the ref callback with the DOM element when the component mounts,\n  // and call it with null when it unmounts.\n  // So, we don't need an useEffect etc to unobserve nodes.\n  // When nodeRef.current is null, it will be unobserved and observe function\n  // won't do anything.\n  const refCallback = useCallback<IntersectionObserverHookRefCallback>(\n    (node) => {\n      unobserve();\n      nodeRef.current = node;\n      observe();\n    },\n    [observe, unobserve],\n  );\n\n  const rootRefCallback = useCallback<IntersectionObserverHookRootRefCallback>(\n    (rootNode) => {\n      unobserve();\n      rootRef.current = rootNode;\n      observe();\n    },\n    [observe, unobserve],\n  );\n\n  return [refCallback, { entry, rootRef: rootRefCallback }];\n}\n\nexport default useIntersectionObserver;\n","import { useState } from 'react';\nimport useIntersectionObserver, {\n  IntersectionObserverHookArgs,\n  IntersectionObserverHookResult,\n} from './useIntersectionObserver';\n\nexport type TrackVisibilityHookArgs = IntersectionObserverHookArgs;\n\nexport type TrackVisibilityHookResult = [\n  IntersectionObserverHookResult[0],\n  IntersectionObserverHookResult[1] & {\n    isVisible: boolean;\n    wasEverVisible: boolean;\n  },\n];\n\nfunction useTrackVisibility(\n  args?: IntersectionObserverHookArgs,\n): TrackVisibilityHookResult {\n  const [ref, result] = useIntersectionObserver(args);\n  const isVisible = Boolean(result.entry?.isIntersecting);\n  const [wasEverVisible, setWasEverVisible] = useState(isVisible);\n\n  if (isVisible && !wasEverVisible) {\n    setWasEverVisible(true);\n  }\n\n  return [ref, { ...result, isVisible, wasEverVisible }];\n}\n\nexport default useTrackVisibility;\n"],"mappings":";SAsBgBA,oBAAA;EACd,IAAMC,YAAY,GAAyB,IAAIC,GAAJ,EAA3C;EAEA,SAASC,WAATA,CAAAC,IAAA;QACEC,IAAA,GAAAD,IAAA,CAAAC,IAAA;MACAC,UAAA,GAAAF,IAAA,CAAAE,UAAA;MACAC,SAAA,GAAAH,IAAA,CAAAG,SAAA;IAEA,IAAIC,WAAW,GAAGP,YAAY,CAACQ,GAAb,CAAiBJ,IAAjB,CAAlB;IAEA,IAAI,CAACG,WAAL,EAAkB;MAChBA,WAAW,GAAG,IAAIN,GAAJ,EAAd;MACAD,YAAY,CAACS,GAAb,CAAiBL,IAAjB,EAAuBG,WAAvB;IACD;IAED,IAAMG,QAAQ,GAAGC,IAAI,CAACC,SAAL,CAAe;MAAEP,UAAU,EAAVA,UAAF;MAAcC,SAAS,EAATA;IAAd,CAAf,CAAjB;IACA,IAAIO,cAAc,GAAGN,WAAW,CAACC,GAAZ,CAAgBE,QAAhB,CAArB;IAEA,IAAI,CAACG,cAAL,EAAqB;MACnB,IAAMC,cAAc,GAAG,IAAIb,GAAJ,EAAvB;MAEA,IAAMc,QAAQ,GAAG,IAAIC,oBAAJ,CACf,UAACC,OAAD;QACEA,OAAO,CAACC,OAAR,CAAgB,UAACC,KAAD;UACd,IAAMC,QAAQ,GAAGN,cAAc,CAACN,GAAf,CAAmBW,KAAK,CAACE,MAAzB,CAAjB;UACAD,QAAQ,QAAR,YAAAA,QAAQ,CAAGD,KAAH,CAAR;QACD,CAHD;MAID,CANc,EAOf;QAAEf,IAAI,EAAJA,IAAF;QAAQC,UAAU,EAAVA,UAAR;QAAoBC,SAAS,EAATA;MAApB,CAPe,CAAjB;MAUAO,cAAc,GAAG;QAAEE,QAAQ,EAARA,QAAF;QAAYD,cAAc,EAAdA;MAAZ,CAAjB;MAEAP,WAAW,CAACE,GAAZ,CAAgBC,QAAhB,EAA0BG,cAA1B;IACD;IAED,OAAO;MACLS,OAAO,EAAE,SAAAA,QACPC,IADO,EAEPH,QAFO;;QAIP,CAAAI,eAAA,GAAAX,cAAc,SAAd,YAAAW,eAAA,CAAgBV,cAAhB,CAA+BL,GAA/B,CAAmCc,IAAnC,EAAyCH,QAAzC;QACA,CAAAK,gBAAA,GAAAZ,cAAc,SAAd,YAAAY,gBAAA,CAAgBV,QAAhB,CAAyBO,OAAzB,CAAiCC,IAAjC;MACD,CAPI;MAQLG,SAAS,EAAE,SAAAA,UAACH,IAAD;;QACT,CAAAI,gBAAA,GAAAd,cAAc,SAAd,YAAAc,gBAAA,CAAgBb,cAAhB,WAAsCS,IAAtC;QACA,CAAAK,gBAAA,GAAAf,cAAc,SAAd,YAAAe,gBAAA,CAAgBb,QAAhB,CAAyBW,SAAzB,CAAmCH,IAAnC;MACD;IAXI,CAAP;EAaD;EAED,OAAO;IAAErB,WAAW,EAAXA;EAAF,CAAP;AACD;ACtED,IAAM2B,mBAAmB,GAAG,KAA5B;AACA,IAAMC,iBAAiB,GAAG,CAAC,CAAD,CAA1B;AA2BA,IAAMC,aAAa,gBAAGhC,mBAAmB,EAAzC;AAGA;AACA;;AACA,SAASiC,uBAATA,CACEC,IADF;;EAGE,IAAM5B,UAAU,IAAA6B,gBAAA,GAAGD,IAAH,oBAAGA,IAAI,CAAE5B,UAAT,YAAA6B,gBAAA,GAAuBL,mBAAvC;EACA,IAAMvB,SAAS,IAAA6B,eAAA,GAAGF,IAAH,oBAAGA,IAAI,CAAE3B,SAAT,YAAA6B,eAAA,GAAsBL,iBAArC;EAEA,IAAMM,OAAO,GAAGC,MAAM,CAA0C,IAA1C,CAAtB;EACA,IAAMC,OAAO,GAAGD,MAAM,CAA8C,IAA9C,CAAtB;EACA,IAAME,WAAW,GAAGF,MAAM,CAAoC,IAApC,CAA1B;kBAE0BG,QAAQ;IAA3BrB,KAAA,GAAAsB,SAAA;IAAOC,QAAA,GAAAD,SAAA;EAEd,IAAMnB,OAAO,GAAGqB,WAAW,CAAC;IAC1B,IAAMpB,IAAI,GAAGa,OAAO,CAACQ,OAArB;IAEA,IAAI,CAACrB,IAAL,EAAW;MACTmB,QAAQ,CAACG,SAAD,CAAR;MACA;IACD;IAED,IAAM9B,QAAQ,GAAGgB,aAAa,CAAC7B,WAAd,CAA0B;MACzCE,IAAI,EAAEkC,OAAO,CAACM,OAD2B;MAEzCvC,UAAU,EAAVA,UAFyC;MAGzCC,SAAS,EAATA;IAHyC,CAA1B,CAAjB;IAMAS,QAAQ,CAACO,OAAT,CAAiBC,IAAjB,EAAuB,UAACuB,aAAD;MACrBJ,QAAQ,CAACI,aAAD,CAAR;IACD,CAFD;IAIAP,WAAW,CAACK,OAAZ,GAAsB7B,QAAtB;EACD,CAnB0B,EAmBxB,CAACV,UAAD,EAAaC,SAAb,CAnBwB,CAA3B;EAqBA,IAAMoB,SAAS,GAAGiB,WAAW,CAAC;IAC5B,IAAMI,eAAe,GAAGR,WAAW,CAACK,OAApC;IACA,IAAMrB,IAAI,GAAGa,OAAO,CAACQ,OAArB;IAEA,IAAIrB,IAAJ,EAAU;MACRwB,eAAe,QAAf,YAAAA,eAAe,CAAErB,SAAjB,CAA2BH,IAA3B;IACD;IAEDgB,WAAW,CAACK,OAAZ,GAAsB,IAAtB;EACD,CAT4B,EAS1B,EAT0B,CAA7B;EAYA;EACA;EACA;EACA;;EACA,IAAMI,WAAW,GAAGL,WAAW,CAC7B,UAACpB,IAAD;IACEG,SAAS;IACTU,OAAO,CAACQ,OAAR,GAAkBrB,IAAlB;IACAD,OAAO;EACR,CAL4B,EAM7B,CAACA,OAAD,EAAUI,SAAV,CAN6B,CAA/B;EASA,IAAMuB,eAAe,GAAGN,WAAW,CACjC,UAACO,QAAD;IACExB,SAAS;IACTY,OAAO,CAACM,OAAR,GAAkBM,QAAlB;IACA5B,OAAO;EACR,CALgC,EAMjC,CAACA,OAAD,EAAUI,SAAV,CANiC,CAAnC;EASA,OAAO,CAACsB,WAAD,EAAc;IAAE7B,KAAK,EAALA,KAAF;IAASmB,OAAO,EAAEW;EAAlB,CAAd,CAAP;AACD;;;;;;;;;;;;;;;ACzFD,SAASE,kBAATA,CACElB,IADF;;8BAGwBD,uBAAuB,CAACC,IAAD;IAAtCmB,GAAA,GAAAC,qBAAA;IAAKC,MAAA,GAAAD,qBAAA;EACZ,IAAME,SAAS,GAAGC,OAAO,EAAAC,aAAA,GAACH,MAAM,CAACnC,KAAR,qBAACsC,aAAA,CAAcC,cAAf,CAAzB;kBAC4ClB,QAAQ,CAACe,SAAD;IAA7CI,cAAA,GAAAlB,SAAA;IAAgBmB,iBAAA,GAAAnB,SAAA;EAEvB,IAAIc,SAAS,IAAI,CAACI,cAAlB,EAAkC;IAChCC,iBAAiB,CAAC,IAAD,CAAjB;EACD;EAED,OAAO,CAACR,GAAD,EAAAS,QAAA,KAAWP,MAAX;IAAmBC,SAAS,EAATA,SAAnB;IAA8BI,cAAc,EAAdA;EAA9B,GAAP;AACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}